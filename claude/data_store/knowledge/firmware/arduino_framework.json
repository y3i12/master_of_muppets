{
  "name": "Arduino Framework",
  "description": "C++ framework for embedded microcontroller development with simplified API",
  "type": "Software Framework",
  "language": "C++",
  "paradigm": "Event-driven, procedural programming",
  "official_documentation": "https://docs.arduino.cc/language-reference/",
  
  "core_philosophy": {
    "simplicity": "Hide low-level hardware complexity behind simple functions",
    "accessibility": "Make embedded programming accessible to beginners",
    "portability": "Same code works across different microcontroller platforms",
    "community": "Large ecosystem of libraries and examples"
  },

  "program_structure": {
    "required_functions": {
      "setup": {
        "description": "Initialization function called once at startup",
        "signature": "void setup()",
        "purpose": "Configure pins, initialize peripherals, set initial states",
        "execution": "Called once after reset"
      },
      "loop": {
        "description": "Main program loop executed continuously",
        "signature": "void loop()",
        "purpose": "Main application logic",
        "execution": "Called repeatedly after setup() completes"
      }
    },
    "optional_functions": {
      "interrupt_handlers": "Custom interrupt service routines",
      "timer_callbacks": "Timer-based callback functions",
      "event_handlers": "Protocol-specific event handlers"
    }
  },

  "core_api": {
    "digital_io": {
      "pinMode": {
        "signature": "void pinMode(uint8_t pin, uint8_t mode)",
        "modes": ["INPUT", "OUTPUT", "INPUT_PULLUP", "INPUT_PULLDOWN"],
        "description": "Configure pin direction and pull resistors",
        "example": "pinMode(13, OUTPUT);"
      },
      "digitalWrite": {
        "signature": "void digitalWrite(uint8_t pin, uint8_t value)",
        "values": ["HIGH (1)", "LOW (0)"],
        "description": "Set digital pin output state",
        "timing": "~4μs execution time",
        "example": "digitalWrite(13, HIGH);"
      },
      "digitalRead": {
        "signature": "int digitalRead(uint8_t pin)",
        "return_values": ["HIGH", "LOW"],
        "description": "Read digital pin input state",
        "example": "int state = digitalRead(2);"
      }
    },
    "analog_io": {
      "analogRead": {
        "signature": "int analogRead(uint8_t pin)",
        "return_range": "0-1023 (10-bit) or 0-4095 (12-bit)",
        "voltage_mapping": "0V = 0, VCC = max_value",
        "description": "Read analog voltage on ADC pin",
        "example": "int value = analogRead(A0);"
      },
      "analogWrite": {
        "signature": "void analogWrite(uint8_t pin, int value)",
        "input_range": "0-255",
        "description": "Generate PWM signal for analog output",
        "frequency": "Platform-dependent (usually 490Hz or 980Hz)",
        "example": "analogWrite(3, 128); // 50% duty cycle"
      },
      "analogReference": {
        "description": "Set ADC reference voltage",
        "options": ["DEFAULT", "INTERNAL", "EXTERNAL"]
      }
    },
    "timing": {
      "delay": {
        "signature": "void delay(unsigned long ms)",
        "description": "Blocking delay in milliseconds",
        "blocking": true,
        "example": "delay(1000); // Wait 1 second"
      },
      "delayMicroseconds": {
        "signature": "void delayMicroseconds(unsigned int us)",
        "description": "Blocking delay in microseconds",
        "range": "3μs to 16383μs",
        "accuracy": "±1μs for values > 3μs"
      },
      "millis": {
        "signature": "unsigned long millis()",
        "description": "Time since program start in milliseconds",
        "overflow": "Every ~50 days",
        "resolution": "1ms"
      },
      "micros": {
        "signature": "unsigned long micros()",
        "description": "Time since program start in microseconds",
        "overflow": "Every ~70 minutes",
        "resolution": "1μs or 4μs depending on platform"
      }
    }
  },

  "communication_libraries": {
    "serial": {
      "class": "Serial",
      "description": "UART communication",
      "initialization": "Serial.begin(baudrate)",
      "methods": {
        "begin": "Initialize serial port",
        "end": "Disable serial port",
        "available": "Check for incoming data",
        "read": "Read single byte",
        "write": "Write data",
        "print": "Print formatted text",
        "println": "Print with newline"
      },
      "example": "Serial.begin(9600); Serial.println(\"Hello\");"
    },
    "wire_i2c": {
      "library": "Wire",
      "description": "I2C (Two Wire Interface) communication",
      "modes": ["Master", "Slave"],
      "initialization": "Wire.begin()",
      "methods": {
        "begin": "Initialize I2C bus",
        "beginTransmission": "Start transmission to device",
        "write": "Queue data for transmission",
        "endTransmission": "Send queued data",
        "requestFrom": "Request data from device",
        "available": "Check for received data",
        "read": "Read received data"
      },
      "example": "Wire.begin(); Wire.beginTransmission(0x68);"
    },
    "spi": {
      "library": "SPI",
      "description": "Serial Peripheral Interface communication",
      "modes": ["Master only"],
      "initialization": "SPI.begin()",
      "methods": {
        "begin": "Initialize SPI bus",
        "end": "Disable SPI",
        "transfer": "Send/receive single byte",
        "transfer16": "Send/receive 16-bit data",
        "beginTransaction": "Start SPI transaction",
        "endTransaction": "End SPI transaction"
      },
      "settings": {
        "clock": "SPI clock speed",
        "bit_order": "MSBFIRST or LSBFIRST",
        "data_mode": "SPI_MODE0, SPI_MODE1, SPI_MODE2, SPI_MODE3"
      }
    }
  },

  "advanced_features": {
    "interrupts": {
      "attachInterrupt": {
        "signature": "attachInterrupt(pin, ISR, mode)",
        "modes": ["RISING", "FALLING", "CHANGE", "LOW", "HIGH"],
        "description": "Attach external interrupt handler",
        "limitations": "ISR should be fast and avoid complex operations"
      },
      "detachInterrupt": "Remove interrupt handler",
      "noInterrupts": "Disable all interrupts",
      "interrupts": "Re-enable interrupts"
    },
    "pwm_control": {
      "analogWriteFrequency": "Set PWM frequency (Teensy)",
      "analogWriteResolution": "Set PWM resolution (Teensy)",
      "tone": "Generate square wave on pin",
      "noTone": "Stop tone generation"
    },
    "eeprom": {
      "library": "EEPROM",
      "description": "Non-volatile memory storage",
      "methods": ["read", "write", "update", "get", "put"],
      "limitations": "Limited write cycles, wear leveling considerations"
    }
  },

  "memory_management": {
    "philosophy": "Avoid dynamic allocation in embedded systems",
    "stack_usage": "Function calls use stack, avoid deep recursion",
    "static_variables": "Persistent across function calls",
    "global_variables": "Available throughout program",
    "progmem": "Store constants in flash memory (AVR)",
    "volatile": "Prevent compiler optimization for hardware registers"
  },

  "teensy_extensions": {
    "description": "Teensyduino extends Arduino framework for Teensy",
    "additional_features": {
      "usb_types": ["Serial", "MIDI", "Keyboard", "Mouse", "Audio"],
      "audio_library": "Real-time audio processing",
      "interval_timer": "Hardware timer interrupts",
      "dma": "Direct Memory Access support",
      "floating_point": "Optimized math functions",
      "multi_serial": "Multiple hardware serial ports"
    }
  },

  "compilation_process": {
    "preprocessing": "Handle #include, #define, conditional compilation",
    "compilation": "C++ to assembly language",
    "assembly": "Assembly to object code",
    "linking": "Combine with libraries, create executable",
    "upload": "Transfer to microcontroller flash memory"
  },

  "best_practices": {
    "initialization": {
      "setup_function": "Initialize all peripherals in setup()",
      "pin_configuration": "Configure pins before use",
      "serial_initialization": "Begin serial communication early for debugging"
    },
    "main_loop": {
      "non_blocking": "Avoid delay() in loop() for responsive programs",
      "state_machines": "Use state machines for complex logic",
      "millis_timing": "Use millis() for non-blocking timing"
    },
    "memory_usage": {
      "string_literals": "Use F() macro for flash strings (AVR)",
      "buffer_sizes": "Size buffers appropriately",
      "stack_depth": "Avoid deep function calls"
    },
    "debugging": {
      "serial_output": "Use Serial.print() for debugging",
      "led_indicators": "Visual feedback with LEDs",
      "watchdog": "Use watchdog timer for crash recovery"
    }
  },

  "common_patterns": {
    "blink_without_delay": {
      "description": "Non-blocking LED blinking pattern",
      "technique": "Use millis() and state variables",
      "benefit": "Allows other code to run simultaneously"
    },
    "button_debouncing": {
      "description": "Handle noisy button inputs",
      "techniques": ["Delay-based", "State machine", "Timer-based"],
      "importance": "Prevents false triggers"
    },
    "sensor_reading": {
      "description": "Periodic sensor data acquisition",
      "patterns": ["Polling", "Interrupt-driven", "Timer-based"],
      "filtering": "Apply digital filters to sensor data"
    },
    "communication_protocols": {
      "request_response": "Send command, wait for response",
      "periodic_reporting": "Regular status updates",
      "event_driven": "Respond to external events"
    }
  },

  "limitations": {
    "real_time": "Not hard real-time due to framework overhead",
    "memory_overhead": "Some RAM/flash overhead compared to bare metal",
    "abstraction_cost": "Function call overhead for simple operations",
    "platform_differences": "Some functions behave differently on different platforms"
  },

  "advantages": {
    "rapid_prototyping": "Quick development and testing",
    "large_ecosystem": "Thousands of libraries available",
    "cross_platform": "Same code works on different microcontrollers",
    "community_support": "Large community and extensive documentation",
    "educational": "Good for learning embedded programming concepts"
  },

  "when_to_use": {
    "good_for": [
      "Prototyping",
      "Educational projects",
      "Hobby projects",
      "Simple commercial products",
      "Rapid development"
    ],
    "alternatives_for": [
      "Hard real-time systems (consider bare metal)",
      "Memory-constrained systems (consider direct register access)",
      "High-performance applications (consider optimized libraries)",
      "Safety-critical systems (consider certified frameworks)"
    ]
  },

  "integration_considerations": {
    "with_rtos": "Can be used with real-time operating systems",
    "with_bare_metal": "Can mix Arduino functions with direct register access",
    "library_compatibility": "Most libraries designed for Arduino framework",
    "porting": "Relatively easy to port between Arduino-compatible platforms"
  }
}