#pragma once

#include "serial_port.h"
#include <sstream>

typedef std::pair<std::string, std::string> serial_device;

template <typename serial_driver>
class slip_encoded_serial_port : public serial_port<serial_driver> {
public:
    static const uint8_t k_end = 0300;
    static const uint8_t k_esc = 0333;
    static const uint8_t k_esc_end = 0334;
    static const uint8_t k_esc_esc = 0335;

    typedef serial_port<serial_driver> _parent_class;

    slip_encoded_serial_port( ) {}
    ~slip_encoded_serial_port( ) {}
    virtual int32_t write( const uint8_t* buffer, size_t len );
    virtual int32_t read( uint8_t* buffer, size_t len );

    template <typename T>
    int32_t send_packet( const T& data ) { return send_packet( reinterpret_cast<const uint8_t*>( &data ), sizeof( data ) ); }
    int32_t send_packet( const uint8_t* buffer, size_t size );
    void begin_packet( void ) { end_packet( ); }
    void end_packet( void ) { this->driver.write( &k_end, 1 ); }
    int32_t receive_packet( uint8_t* buffer, size_t size );
};

template <class serial_driver>
int32_t slip_encoded_serial_port<serial_driver>::write( const uint8_t* buffer, size_t size ) {
    size_t pending( size );

    // for each byte in the packet, send the appropriate character sequence
    while ( pending-- ) {
        switch ( *buffer ) {
          // if it's the same code as an k_end character, we send a
          // special two character code so as not to make the
          // receiver think we sent an k_end
            case k_end:
            this->driver.write( &k_esc, 1 );
            this->driver.write( &k_esc_end, 1 );
            break;

            // if it's the same code as an k_esc character,
            // we send a special two character code so as not
            // to make the receiver think we sent an k_esc
            case k_esc:
            this->driver.write( &k_esc, 1 );
            this->driver.write( &k_esc_esc, 1 );
            break;

            // otherwise, we just send the character
            default:
            this->driver.write( buffer, 1 );
        }

        ++buffer;
    }

    return static_cast<int32_t>( size );
}

template <class serial_driver>
int32_t slip_encoded_serial_port<serial_driver>::read( uint8_t* buffer, size_t size ) {
    uint8_t byte( 0 );
    size_t received( 0 );

    // sit in a loop reading bytes until we put together a whole packet.
    // Make sure not to copy them into the packet if we run out of room.
    while ( received < size ) {
      // get a byte to process
        this->driver.read( &byte, 1 );

        // handle bytestuffing if necessary
        switch ( byte ) {
        // if it's an k_end character then we're done with the packet
            case k_end:
              // a minor optimization: if there is no data in the packet, ignore it. This is
              // meant to avoid bothering IP with all the empty packets generated by the
              // duplicate k_end characters which are in turn sent to try to detect line noise.
            if ( received ) {
                return static_cast<int32_t>( received );
            } else {
                break;
            }

          // if it's the same code as an k_esc character, wait and get another character and then figure out
          // what to store in the packet based on that.
            case k_esc:
            this->driver.read( &byte, 1 );

            // if "byte" is not one of these two, then we have a protocol violation.  The best bet
            // seems to be to leave the byte alone and just stuff it into the packet
            switch ( byte ) {
                case k_esc_end:
                byte = k_end;
                break;
                case k_esc_esc:
                byte = k_esc;
                break;
            }

          // here we fall into the default handler and let store the character for us
            default:
            buffer[received++] = byte;
        }
    }

    return static_cast<int32_t>( received );
}

template <class serial_driver>
int32_t slip_encoded_serial_port<serial_driver>::send_packet( const uint8_t* buffer, size_t size ) {
    if ( !size ) {
        return 0;
    }

    // send an initial END character to flush out any data that may
    // have accumulated in the receiver due to line noise
    begin_packet( );

    int32_t sent = write( buffer, size );

    // tell the receiver that we're done sending the packet
    end_packet( );

    return sent;
}

template <class serial_driver>
int32_t slip_encoded_serial_port<serial_driver>::receive_packet( uint8_t* buffer, size_t size ) {
    return read( buffer, size );
}
