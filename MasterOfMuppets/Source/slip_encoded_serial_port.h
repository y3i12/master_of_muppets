#pragma once

#include "serial_port.h"
#include <sstream>
#include <vector>

typedef std::pair< std::string, std::string > serial_device;

template < typename serial_driver >
class slip_encoded_serial_port : public serial_port< serial_driver > {
protected:
    std::vector< uint8_t > _buffer;

public:
    static const uint8_t k_end      = 0300;
    static const uint8_t k_esc      = 0333;
    static const uint8_t k_esc_end  = 0334;
    static const uint8_t k_esc_esc  = 0335;

    typedef serial_port< serial_driver >              _parent_class;
    typedef slip_encoded_serial_port< serial_driver > _class;

    slip_encoded_serial_port( ) {}
    ~slip_encoded_serial_port( ) {}
    int32_t write( const uint8_t* buffer, size_t len );
    int32_t read( uint8_t* buffer, size_t len );

    template <typename T>
    int32_t send_packet( const T& data ) { return send_packet( reinterpret_cast<const uint8_t*>( &data ), sizeof( data ) ); }
    int32_t send_packet( const uint8_t* buffer, size_t size );

    void begin_packet( void ) { this->_parent_class::write( &k_end, 1 ); }
    void end_packet( void ) { this->_parent_class::write( &k_end, 1 ); this->_class::flush( ); }

    int32_t receive_packet( uint8_t* buffer, size_t size );

    void flush( void );
};

template < class serial_driver >
int32_t slip_encoded_serial_port< serial_driver >::write( const uint8_t* buffer, size_t size ) {
    size_t pending( size );

    // for each byte in the packet, send the appropriate character sequence
    while ( pending-- ) {
        switch ( *buffer ) {
            // if it's the same code as an k_end character, send a
            // special two character code so as not to make the
            // receiver think a k_end was send
            case k_end:
            _buffer.push_back( k_esc );
            _buffer.push_back( k_esc_end );
            break;

            // if it's the same code as an k_esc character,
            // send a special two character code so as not
            // to make the receiver think k_esc was sent
            case k_esc:
            _buffer.push_back( k_esc );
            _buffer.push_back( k_esc_esc );
            break;

            // otherwise, send the original character
            default:

            _buffer.push_back( *buffer );
        }

        ++buffer;
    }

    return static_cast< int32_t >( size );
}

template < class serial_driver >
int32_t slip_encoded_serial_port< serial_driver >::read( uint8_t* buffer, size_t size ) {
    uint8_t byte( 0 );
    size_t  received( 0 );

    // sit in a loop reading bytes until we put together a whole packet.
    // Make sure not to copy them into the packet if we run out of room.
    while ( received < size ) {
        // get a byte to process
        this->_parent_class::read( &byte, 1 );

        // handle bytestuffing if necessary
        switch ( byte ) {
            // if it's an k_end character then we're done with the packet
            case k_end:
            // a minor optimization: if there is no data in the packet, ignore it. This is
            // meant to avoid bothering IP with all the empty packets generated by the
            // duplicate k_end characters which are in turn sent to try to detect line noise.
            if ( received ) {
                return static_cast< int32_t >( received );
            } else {
                break;
            }

            // if it's the same code as an k_esc character, wait and get another character and then figure out
            // what to store in the packet based on that.
            case k_esc:
            this->_parent_class::read( &byte, 1 );

            // if "byte" is not one of these two, then we have a protocol violation.  The best bet
            // seems to be to leave the byte alone and just stuff it into the packet
            switch ( byte ) {
                case k_esc_end:
                byte = k_end;
                break;
                case k_esc_esc:
                byte = k_esc;
                break;
            }

            // here we fall into the default handler and let store the character for us
            default:
            buffer[ received++ ] = byte;
        }
    }

    return static_cast< int32_t >( received );
}

template < class serial_driver >
int32_t slip_encoded_serial_port< serial_driver >::send_packet( const uint8_t* buffer, size_t size ) {
    if ( !size ) {
        return 0;
    }

    // send an initial END character to flush out any data that may
    // have accumulated in the receiver due to line noise
    begin_packet( );

    int32_t sent = this->_class::write( buffer, size );

    // tell the receiver that we're done sending the packet and flussh it down the toilet
    end_packet( );

    return sent;
}

template < class serial_driver >
int32_t slip_encoded_serial_port< serial_driver >::receive_packet( uint8_t* buffer, size_t size ) {
    return this->_class::read( buffer, size );
}


template < class serial_driver >
void slip_encoded_serial_port< serial_driver >::flush( void ) {
    this->_parent_class::write( _buffer.data(), _buffer.size( ) );
    this->_parent_class::flush( );
    _buffer.clear( );
}